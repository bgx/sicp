#lang sicp

; 2.3.3

; sets as unordered lists -- a list of its elements in which no element appears more than once
(define (unordered-list-impl)
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))
  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))
  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))
  (define (union-set set1 set2)
    (define (union-set-iter set1 filled-set)
      (cond ((null? set1) (append filled-set set2))
            ((element-of-set? (car set1) set2) 
             (union-set-iter (cdr set1) filled-set))
            (else (union-set-iter (cdr set1) (cons (car set1) filled-set)))))
    (union-set-iter set1 '()))
  (list element-of-set? adjoin-set intersection-set union-set))

; sets as unordered lists, with duplicates allowed
(define (unordered-list-duplicates-impl)
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))
  (define (adjoin-set x set)
    (cons x set))
  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))
  (define (union-set set1 set2)
    (append set1 set2))
  (list element-of-set? adjoin-set intersection-set union-set))

; sets as ordered lists -- set elements are listed in increasing order
(define (ordered-list-impl)
  (define (element-of-set? x set)
    (cond ((null? set) false)
          ((= x (car set)) true)
          ((< x (car set)) false)
          (else (element-of-set? x (cdr set)))))
  (define (adjoin-set x set)
    (cond ((null? set) (list x))
          ((< x (car set)) (cons x set))
          ((= x (car set)) set)
          (else (cons (car set) (adjoin-set x (cdr set))))))
  (define (intersection-set set1 set2)
    (if (or (null? set1) (null? set2))
        '()
        (let ((x1 (car set1)) (x2 (car set2)))
          (cond ((= x1 x2)
                 (cons x1
                       (intersection-set (cdr set1)
                                         (cdr set2))))
                ((< x1 x2)
                 (intersection-set (cdr set1) set2))
                ((< x2 x1)
                 (intersection-set set1 (cdr set2)))))))
  (define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          (else
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1
                           (union-set (cdr set1)
                                      (cdr set2))))
                    ((< x1 x2)
                     (cons x1
                           (union-set (cdr set1) set2)))
                    ((< x2 x1)
                     (cons x2
                           (union-set set1 (cdr set2)))))))))
  (list element-of-set? adjoin-set intersection-set union-set))

; sets as binary trees
(define (binary-tree-impl)
  (define (element-of-set? x set)
    (cond ((null? set) false)
          ((= x (entry set)) true)
          ((< x (entry set))
           (element-of-set? x (left-branch set)))
          ((> x (entry set))
           (element-of-set? x (right-branch set)))))
  (define (adjoin-set x set)
    (cond ((null? set) (make-tree x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-tree (entry set) 
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> x (entry set))
           (make-tree (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))
  (define (intersection-set set1 set2)
    (list->tree ((caddr (ordered-list-impl)) (tree->list set1) (tree->list set2))))
  (define (union-set set1 set2)
    (list->tree ((cadddr (ordered-list-impl)) (tree->list set1) (tree->list set2))))
  (list element-of-set? adjoin-set intersection-set union-set))

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

(define sampletree1 (make-tree 7 (make-tree 3
                                            (make-tree 1 '() '())
                                            (make-tree 5 '() '()))
                                 (make-tree 9
                                            '()
                                            (make-tree 11 '() '()))))
(define sampletree2 (make-tree 3 (make-tree 1 '() '())
                                 (make-tree 7
                                            (make-tree 5 '() '())
                                            (make-tree 9
                                                       '()
                                                       (make-tree 11 '() '())))))
(define sampletree3 (make-tree 5 (make-tree 3
                                            (make-tree 1 '() '())
                                            '())
                                 (make-tree 9
                                            (make-tree  7 '() '())
                                            (make-tree 11 '() '()))))
(define sampletree4 (make-tree 6 (make-tree 4
                                            (make-tree 2 '() '())
                                            '())
                                 (make-tree 10
                                            (make-tree  8 '() '())
                                            (make-tree 12 '() '()))))

(define (tree->list tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))

(define set-impl (binary-tree-impl))
(define (element-of-set? x set)
  ((car set-impl) x set))
(define (adjoin-set x set)
  ((cadr set-impl) x set))
(define (intersection-set set1 set2)
  ((caddr set-impl) set1 set2))
(define (union-set set1 set2)
  ((cadddr set-impl) set1 set2))

;;;;;;;;;;;;;; Experimental Below ;;;;;;;;;;;;;;;;;;
